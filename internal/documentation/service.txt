// package documentations

// import (
// 	"backend/internal/domain"
// 	"backend/internal/projects"
// 	"backend/pkg/errors"
// 	"time"
// )

// type Service struct {
// 	repo        Repository
// 	projectRepo projects.Repository
// }

// func NewService(r Repository, projectRepo projects.Repository) *Service {
// 	return &Service{
// 		repo:        r,
// 		projectRepo: projectRepo,
// 	}
// }

// func (s *Service) UploadDocument(projectID, userID uint, documentType, fileURL string) (*domain.ProjectDocumentation, error) {
// 	project, err := s.projectRepo.GetByID(projectID)
// 	if err != nil {
// 		return nil, errors.NewNotFoundError("Project not found")
// 	}

// 	if project.Team.CreatedBy != userID {
// 		isMember := false
// 		for _, member := range project.Team.Members {
// 			if member.ID == userID {
// 				isMember = true
// 				break
// 			}
// 		}
// 		if !isMember {
// 			return nil, errors.NewForbiddenError("Only team members can upload documentation")
// 		}
// 	}

// 	doc := &domain.ProjectDocumentation{
// 		ProjectID:    projectID,
// 		DocumentType: documentType,
// 		FileURL:      fileURL,
// 		Status:       "pending",
// 		SubmittedBy:  userID,
// 		SubmittedAt:  time.Now(),
// 	}

// 	if err := s.repo.Create(doc); err != nil {
// 		return nil, errors.NewInternalServerError("Failed to upload document")
// 	}

// 	return doc, nil
// }

// func (s *Service) GetProjectDocuments(projectID uint) ([]domain.ProjectDocumentation, error) {
// 	return s.repo.GetByProjectID(projectID)
// }

// func (s *Service) GetDocument(id uint) (*domain.ProjectDocumentation, error) {
// 	doc, err := s.repo.GetByID(id)
// 	if err != nil {
// 		return nil, errors.NewNotFoundError("Document not found")
// 	}
// 	return doc, nil
// }

// func (s *Service) ReviewDocument(id, reviewerID uint, approve bool, comment string) error {
// 	_, err := s.repo.GetByID(id)
// 	if err != nil {
// 		return errors.NewNotFoundError("Document not found")
// 	}

// 	if approve {
// 		return s.repo.ApproveDocument(id, reviewerID, comment)
// 	}
// 	return s.repo.RejectDocument(id, reviewerID, comment)
// }
