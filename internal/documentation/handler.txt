// package documentation

// import (
// 	"backend/pkg/response"
// 	"net/http"
// 	"strconv"

// 	"github.com/gin-gonic/gin"
// )

// type Handler struct {
// 	service *Service
// }

// func NewHandler(s *Service) *Handler {
// 	return &Handler{service: s}
// }

// type UploadDocumentRequest struct {
// 	ProjectID    uint   `json:"project_id" binding:"required"`
// 	DocumentType string `json:"document_type" binding:"required"`
// 	FileURL      string `json:"file_url" binding:"required"`
// }

// type ReviewDocumentRequest struct {
// 	Approve bool   `json:"approve" binding:"required"`
// 	Comment string `json:"comment"`
// }

// // UploadDocument godoc
// // @Summary Upload project documentation
// // @Description Upload documentation for a project (team members only)
// // @Tags Documentation
// // @Accept json
// // @Produce json
// // @Security BearerAuth
// // @Param request body UploadDocumentRequest true "Document upload details"
// // @Success 201 {object} response.Response{data=domain.ProjectDocumentation}
// // @Failure 400 {object} response.ErrorResponse
// // @Failure 403 {object} response.ErrorResponse
// // @Failure 500 {object} response.ErrorResponse
// // @Router /documentation [post]
// func (h *Handler) UploadDocument(c *gin.Context) {
// 	var req UploadDocumentRequest
// 	if err := c.ShouldBindJSON(&req); err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid request body", err.Error())
// 		return
// 	}

// 	userID := c.GetUint("user_id")
// 	doc, err := h.service.UploadDocument(req.ProjectID, userID, req.DocumentType, req.FileURL)
// 	if err != nil {
// 		response.Error(c, http.StatusInternalServerError, "Failed to upload document", err.Error())
// 		return
// 	}

// 	response.JSON(c, http.StatusCreated, "Document uploaded successfully", doc)
// }

// // GetProjectDocuments godoc
// // @Summary Get project documents
// // @Description Get all documents for a specific project
// // @Tags Documentation
// // @Produce json
// // @Security BearerAuth
// // @Param project_id path int true "Project ID"
// // @Success 200 {object} response.Response{data=[]domain.ProjectDocumentation}
// // @Failure 500 {object} response.ErrorResponse
// // @Router /projects/{project_id}/documentation [get]
// func (h *Handler) GetProjectDocuments(c *gin.Context) {
// 	projectID, err := strconv.ParseUint(c.Param("project_id"), 10, 32)
// 	if err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid project ID", err.Error())
// 		return
// 	}

// 	docs, err := h.service.GetProjectDocuments(uint(projectID))
// 	if err != nil {
// 		response.Error(c, http.StatusInternalServerError, "Failed to retrieve documents", err.Error())
// 		return
// 	}

// 	response.JSON(c, http.StatusOK, "Documents retrieved successfully", docs)
// }

// // GetDocument godoc
// // @Summary Get document details
// // @Description Get details of a specific document
// // @Tags Documentation
// // @Produce json
// // @Security BearerAuth
// // @Param id path int true "Document ID"
// // @Success 200 {object} response.Response{data=domain.ProjectDocumentation}
// // @Failure 404 {object} response.ErrorResponse
// // @Router /documentation/{id} [get]
// func (h *Handler) GetDocument(c *gin.Context) {
// 	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
// 	if err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid document ID", err.Error())
// 		return
// 	}

// 	doc, err := h.service.GetDocument(uint(id))
// 	if err != nil {
// 		response.Error(c, http.StatusNotFound, "Document not found", err.Error())
// 		return
// 	}

// 	response.JSON(c, http.StatusOK, "Document retrieved successfully", doc)
// }

// // ReviewDocument godoc
// // @Summary Review project documentation
// // @Description Approve or reject project documentation (teachers/advisors only)
// // @Tags Documentation
// // @Accept json
// // @Produce json
// // @Security BearerAuth
// // @Param id path int true "Document ID"
// // @Param request body ReviewDocumentRequest true "Review decision"
// // @Success 200 {object} response.Response
// // @Failure 400 {object} response.ErrorResponse
// // @Failure 404 {object} response.ErrorResponse
// // @Router /documentation/{id}/review [post]
// func (h *Handler) ReviewDocument(c *gin.Context) {
// 	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
// 	if err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid document ID", err.Error())
// 		return
// 	}

// 	var req ReviewDocumentRequest
// 	if err := c.ShouldBindJSON(&req); err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid request body", err.Error())
// 		return
// 	}

// 	reviewerID := c.GetUint("user_id")
// 	if err := h.service.ReviewDocument(uint(id), reviewerID, req.Approve, req.Comment); err != nil {
// 		response.Error(c, http.StatusInternalServerError, "Failed to review document", err.Error())
// 		return
// 	}

// 	status := "approved"
// 	if !req.Approve {
// 		status = "rejected"
// 	}
// 	response.JSON(c, http.StatusOK, "Document "+status+" successfully", nil)
// }


// // GetProject godoc
// // @Summary Get project by ID
// // @Description Retrieve specific project details
// // @Tags Projects
// // @Produce json
// // @Security BearerAuth
// // @Param id path int true "Project ID"
// // @Success 200 {object} response.Response{data=domain.Project}
// // @Failure 400 {object} response.ErrorResponse
// // @Failure 404 {object} response.ErrorResponse
// // @Router /projects/{id} [get]
// func (h *Handler) GetProject(c *gin.Context) {
// 	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
// 	if err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid project ID", err.Error())
// 		return
// 	}

// 	project, err := h.service.GetProject(uint(id))
// 	if err != nil {
// 		response.Error(c, http.StatusNotFound, "Project not found", err.Error())
// 		return
// 	}

// 	response.Success(c, project)
// }

// // UpdateProject godoc
// // @Summary Update project details
// // @Description Update project summary and keywords
// // @Tags Projects
// // @Accept json
// // @Produce json
// // @Security BearerAuth
// // @Param id path int true "Project ID"
// // @Param project body UpdateProjectRequest true "Updated project details"
// // @Success 200 {object} response.Response{data=domain.Project}
// // @Failure 400 {object} response.ErrorResponse
// // @Failure 401 {object} response.ErrorResponse
// // @Failure 403 {object} response.ErrorResponse
// // @Failure 500 {object} response.ErrorResponse
// // @Router /projects/{id} [put]
// func (h *Handler) UpdateProject(c *gin.Context) {
// 	claims, exists := c.Get("claims")
// 	if !exists {
// 		response.Error(c, http.StatusUnauthorized, "Unauthorized", "No authentication claims found")
// 		return
// 	}

// 	userClaims := claims.(*auth.TokenClaims)

// 	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
// 	if err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid project ID", err.Error())
// 		return
// 	}

// 	var req UpdateProjectRequest
// 	if err := c.ShouldBindJSON(&req); err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid request body", err.Error())
// 		return
// 	}

// 	project, err := h.service.UpdateProject(uint(id), req, userClaims.UserID)
// 	if err != nil {
// 		if err.Error() == "only team creator can update project" {
// 			response.Error(c, http.StatusForbidden, "Forbidden", err.Error())
// 			return
// 		}
// 		response.Error(c, http.StatusInternalServerError, "Failed to update project", err.Error())
// 		return
// 	}

// 	response.JSON(c, http.StatusOK, "Project updated successfully", project)
// }

// // PublishProject godoc
// // @Summary Publish project to public archive
// // @Description Make project visible to public users
// // @Tags Projects
// // @Produce json
// // @Security BearerAuth
// // @Param id path int true "Project ID"
// // @Success 200 {object} response.Response
// // @Failure 400 {object} response.ErrorResponse
// // @Failure 401 {object} response.ErrorResponse
// // @Failure 403 {object} response.ErrorResponse
// // @Failure 500 {object} response.ErrorResponse
// // @Router /projects/{id}/publish [post]
// func (h *Handler) PublishProject(c *gin.Context) {
// 	claims, exists := c.Get("claims")
// 	if !exists {
// 		response.Error(c, http.StatusUnauthorized, "Unauthorized", "No authentication claims found")
// 		return
// 	}

// 	userClaims := claims.(*auth.TokenClaims)

// 	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
// 	if err != nil {
// 		response.Error(c, http.StatusBadRequest, "Invalid project ID", err.Error())
// 		return
// 	}

// 	err = h.service.PublishProject(uint(id), userClaims.UserID)
// 	if err != nil {
// 		if err.Error() == "only team creator can publish project" {
// 			response.Error(c, http.StatusForbidden, "Forbidden", err.Error())
// 			return
// 		}
// 		response.Error(c, http.StatusInternalServerError, "Failed to publish project", err.Error())
// 		return
// 	}

// 	response.JSON(c, http.StatusOK, "Project published successfully", nil)
// }
